1.  Integer Operations under multithreads
    On most machine, Integer operation is in a single instruction, which means the operation to integer is un-interruptable.
    Then why we still need to use lock to protect the access to integer when multi-threads?
   
    Even this single instruction contains 3 steps:
    (1) CPU core fetches data from cache;
    (2) Do operation;
    (3) Write back to store buffer;

    Example: You have a shared int variable initialized to 0. And a function increasing its value by 1 for 100 times.
    Now you create a thread vector with 10 of this threads, what is the value of this int at the end? 
    ------------------------------
    Is it 1000? Very possible NOT.
    ------------------------------
    Because: 
    (1) If you are expecting 1000, the 10 threads should be:
           thread-1       thread-2       thread-3              thread-10
        |--------------|--------------|--------------|......|--------------|
    (2) But actually:
        |--------------|
              |--------------|
                     |---------------------|
                     ...
                               |--------------|
        Not only they are interleaved, but also some earlier started threads may ends later than threads started later.

    So, if you expect 1000, you should add lock to each threads, so that they actually run one by one.
    // -----------------------------------------------------------------------------------------------
    void selfIncrement(void)
    {
        // 1. Guard can be added here       
        // std::lock_guard<std::mutex> rwGuard(rwMutex);
        for (int i = 0; i < 100000; i ++)
        {
            // 2. Guard can also be added here so every increment is using previous data.
            std::lock_guard<std::mutex> rwGuard(rwMutex);
            data++;
        }
    }
    // -----------------------------------------------------------------------------------------------
    Above 2 also means that we can make data a atomic variable.

2.  Atomic Variable

    Compiler will generate special instructions that:
    1. Prevent CPU to pre-fetch atomic variables. It will only fetch data when thread needs it;
    2. It also forces CPU cores to flush its store buffer immediately;
    It will turn off all optimizations to the access of atomic variable, so the operations will take longer than usual.

    When you make a variable atomic, all operations on this variable become atomic. Other threads can't interleave its operation.

    You need to initialize variable when you declare it.
    ----------------------------------------------------------------------------------------------------------------------------
    #include <atom>
    atomic<int> x = 0;
    x = 2;
    y = x; // y need not to be atomic
    // Both of above 2 operations are atomic, for themselves. Other thread can interleave between the 2 steps, and changing the 
    // value of x before "y = x". 
    ----------------------------------------------------------------------------------------------------------------------------

    Usually, the types here are what called "trivially copyable". The most common ones are integers and pointers.
    For classes:
    (1) Use lock and unlock;    
    (2) If atomic, the class's copy and assignment ctors should be trivial. And it is better to use pointer for class.






