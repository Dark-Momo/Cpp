1.  Integer Operations under multithreads
    On most machine, Integer operation is in a single instruction, which means the operation to integer is un-interruptable.
    Then why we still need to use lock to protect the access to integer when multi-threads?

    Example: You have a shared int variable initialized to 0. And a function increasing its value by 1 for 100 times.
    Now you create a thread vector with 10 of this threads, what is the value of this int at the end? 
    ------------------------------
    Is it 1000? Very possible NOT.
    ------------------------------
    Because: 
    (1) If you are expecting 1000, the 10 threads should be:
           thread-1       thread-2       thread-3              thread-10
        |--------------|--------------|--------------|......|--------------|
    (2) But actually:
        |--------------|
              |--------------|
                     |---------------------|
                     ...
                               |--------------|
        Not only they are interleaved, but also some earlier started threads may ends later than threads started later.

    So, if you expect 1000, you should add lock to each threads, so that they actually run one by one.
    // -----------------------------------------------------------------------------------------------
    void selfIncrement(void)
    {
        // 1. Guard can be added here       
        // std::lock_guard<std::mutex> rwGuard(rwMutex);
        for (int i = 0; i < 100000; i ++)
        {
            // 2. Guard can also be added here so every increment is using previous data.
            std::lock_guard<std::mutex> rwGuard(rwMutex);
            data++;
        }
    }
    // -----------------------------------------------------------------------------------------------
