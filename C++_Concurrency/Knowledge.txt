1. std::thread th(FunctionName) will create a new thread and run it immediately. The thread function can't be overloaded. 
   So don't use an existing function name.

2. std::ref() and its purpose in CodeList.txt.

3. std::thread is C++ interface for multithreading, but it doesn't implement all necessary functions for multithreading 
   because we want a implementation portable to all platforms, and some platforms are limited.
   
   One function that C++ std::thread doesn't provide is setting the priority of thread.

   Thread affinity is to assign a thread on a specific core or not. Usually scheduler will move a thread on different core
   if it think necessary. But this move would involve context switch.

   native_handle() member function is something that the thread implementation would use to associate with the std::thread.
   It returns different value, and has different meaning for different platforms. See code example and CodeList.txt for this.

4. std::thread is implemented using RAII. What does this mean?
   When passing thread as a function argument, it can only be done with std::move(). Don't do it with value passing.
   When returning a thread, compiler will always do std::move() to it.

5. A thread's exception should be handled in the thread itself. Other thread, incluing its parent, can't handle for it.
   If no suitable handler is found, the whole program will be terminated.
 
6. std::thread doesn't support kill to it. You may rely on OS to kill it.

-------------------------------------------------------------------------------------------------------------------------------
7. Data Race
   When several threads are accessing the same memory location and one of the thread is trying to modify it, this modification
   may be interrupted by other threads, due to lack of synchonization, before it is done. So the data is corrupted here.
   
   We may enforce a sequential access to this shared data between threads, and threads will still run concurrently at other 
   time.

   Critical section is the code section that requires execution thread by thread. Usually it is where shared data is. 

8. Thread synchronization, by Mutex, is the solution to data race.
   std::mutex is a class, with 3 member functions only: 
   (1) lock()     : Locks the mutex, blocks if the mutex is not available. Block until succeed.
       Potential danger that if it keeps failing lock, the thread will keeps running forever.  
   (2) try_lock() : Tries to lock the mutex, returns if the mutex is not available;  
   (3) unlock()   : Unlocks the mutex;

   But std::mutex is not usaully directly manipulated using these 3 functions. It is more commonly operated by std::unique_lock, 
   std::lock_guard, or std::scoped_lock (since C++17) manage locking in a more exception-safe manner.
   
