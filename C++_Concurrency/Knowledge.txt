1. std::thread th(FunctionName) will create a new thread and run it immediately. The thread function can't be overloaded. 
   So don't use an existing function name.

2. std::ref() and its purpose in CodeList.txt.

3. std::thread is C++ interface for multithreading, but it doesn't implement all necessary functions for multithreading 
   because we want a implementation portable to all platforms, and some platforms are limited.
   
   One function that C++ std::thread doesn't provide is setting the priority of thread.

   Thread affinity is to assign a thread on a specific core or not. Usually scheduler will move a thread on different core
   if it think necessary. But this move would involve context switch.

   native_handle() member function is something that the thread implementation would use to associate with the std::thread.
   It returns different value, and has different meaning for different platforms. See code example and CodeList.txt for this.

4. std::thread is implemented using RAII. What does this mean?
   When passing thread as a function argument, it can only be done with std::move(). Don't do it with value passing.
   When returning a thread, compiler will always do std::move() to it.

5. A thread's exception should be handled in the thread itself. Other thread, incluing its parent, can't handle for it.
   If no suitable handler is found, the whole program will be terminated.
 
6. std::thread doesn't support kill to it. You may rely on OS to kill it.

-------------------------------------------------------------------------------------------------------------------------------
7. Data Race
   When several threads are accessing the same memory location and one of the thread is trying to modify it, this modification
   may be interrupted by other threads, due to lack of synchonization, before it is done. So the data is corrupted here.
   
   We may enforce a sequential access to this shared data between threads, and threads will still run concurrently at other 
   time.

   Critical section is the code section that requires execution thread by thread. Usually it is where shared data is. 

8. Thread synchronization, by Mutex, is the solution to data race.
   std::mutex is a class, with 3 member functions only: 
   (1) lock()     : Locks the mutex, blocks if the mutex is not available. Block until succeed.
       Potential danger that if it keeps failing to lock, the thread will keeps running forever.
   (2) try_lock() : Tries to lock the mutex, returns if the mutex is not available;  
   (3) unlock()   : Unlocks the mutex;

   You can set std::mutex as your class member to protect the access to your class data.
   For this case, we should use mutex to do synchronization for both reader and writer for a critical region.
   
   *************************************************************************************************************************
   std::mutex is not usaully directly manipulated using these 3 functions. 
   The reason is: If there is any exception throw() between lock() and unlock(), the mutex will never be released, so other
   threads will be blocked there, waiting for the mutex. So is the main(), which will also be blocked forever.
   *************************************************************************************************************************

   It is more commonly operated by std::unique_lock, std::lock_guard, or std::scoped_lock (since C++17) manage locking in a 
   more exception-safe manner. 
   This is RAII way. Basically, the constructor locks, and their destructor unlocks. And we create these classes on stack.
   
   (1) std::lock_guard - It only has constructor, with mutex as parameter, and destructor.
       std::lock_guard<std::mutex> lockGuard(myMutexObj);
   
   (2) std::unique_lock - Similar to std::lock_guard on the constructor locks, and the destructor unlocks. It also has a
       specific unlock() function to solve the problem of double unlock() about std::lock_guard, which is shown 
       in 10-1-RAII-LockGuard.cpp.

       std::unique_lock als has some more features.

       Both std::lock_guard and std::unique_lock are blocking ways.

    In general, if you want to lock the whole scope, use std::lock_guard, otherwise, like you want to lock inside the scope,
    or need othere features, use std::unique_lock.

    std::timed_mutex 
    (1) It supports delayed lock/unlock operations, such as try_lock_for() and try_lock_until(). Take try_lock_for() as example, 
        it will keep trying lock() in the specified duration, and return true/false when this duration is over;
    (2) We can also use std::unique_lock() to wrap a std::timed_mutex.
        std::unique_lock() also has member function try_lock_for() and try_lock_until(), and they are usable when std::unique_lock()
        is wrapping a std::timed_mutex, not just std::mutex.

    So 2 ways:
    std::timed_mutex.try_lock_for()/until(), or, std::unique_lock<std::timed_mutex>.try_lock_for()/until().  

9. Read-Writer Lock
   (1) When there are write or multiple write - need mutex to lock;
   (2) When there are read and write          - need mutex to lock;
   (3) When there are only read               - NO need for mutex to lock;

   - Exclusive Lock : No other thread can acquire the lock/enter the critical region;
     -------------------------------------------------------------------------------------------------
     std::lock_guard<std::shared_mutex> and std::unique_lock<std::shared_mutex> create EXCLUSIVE lock;
     -------------------------------------------------------------------------------------------------

   - Shared Lock    : Other threads may acquire the lock and excute the critical region concurrently;
     --------------------------------------------------------
     std::shared_lock<std::shared_mutex> creates SHARED lock;
     --------------------------------------------------------
     A thread with a shared lock can enter the critical section when there is NO exclusive lock on the same shared_mutex, as described
     just above, or the shared_mutex is released.

10. Shared Data
    Shared data has 4 cases:
    (1) Global variable;
    (2) Static variable at namespace scope;
    (3) Static class member;
    (4) Local variable declared as static (normally in function);

    (1)(2)(3) are initialized when program starts, so there is only one thread then. No data race issue;
 
    (4) is initialized when program runs:
    -------------------------------------------------------------------------------------------------
        void func()
        {
            // Static local variable
            static std::string str("xyz");
        }
    -------------------------------------------------------------------------------------------------
    What if there are many thread calling this function? 
    - For Initialization : The first thread will initialize it, and following will take the initialized value from the first thread;
    - For following use  : Follow the normal rule. There will be data race and we need to take protection.

11. Thread-Local Variable
    The problem of global, and 'static', variable is that it is shared by different threads, so has data race.

    'thread_local' keyword defines a local copy the (1) global, (2) at namespce scope, (3) data member of class, 
    or (4) local variables in function.

12. Double-Check Locking
    All discussion below is about shared variables that need to be initialized/assigned Once in a function. 
 
    // --------------------------------------------------------------------------------
    Singleton * Singleton::initialize_Singleton()
    {
        // We have data race here since several thread may reach here at the same time.
        if (pSingleton == nullptr)
        {
            pSingleton = new Singleton; // This new will call ctor.
        }
        return pSingleton;
    }
    // --------------------------------------------------------------------------------

    [Solution 1] Normal Mutex
    We can add Mutex and lock() before, and unlock() after. It is thread-safe with this mutex lock() and unlock().
    But we will have performance issue since later thread should not concern about initialization and should not lock().

    [Solution 2 - MOST RECOMMENDED] Meyer-Singleton Using Static. We don't declare a static member in class.

    (Semi-Solution 2.5) Double-Check Locking
    The source of the problem is:
    ------------------------------------------------
    if(!pTest)
    {
        std::lock_guard<std::mutex> myLock(myMutex);
        pTest = new Test;
    }
    ------------------------------------------------
    The issue here is:
    (1) Thread A checks the pTest and it is nullptr;
    (2) Thread B checks the pTest and it is nullptr;
    (3) Thread B lock, initialize the pTest, unlock;
    (4) Thread A still thinks pTest as nullptr, so lock, initialize the pTest, unlock;

    So we have improvement as Doubl-Check Locking
    ------------------------------------------------
    if(!pTest)
    {
        std::lock_guard<std::mutex> myLock(myMutex);
        if(!pTest)
        {
            pTest = new Test;
        }
    }
    ------------------------------------------------
    So Step (4) above would be disabled by the second check if(!pTest).
    
    BUT THERE IS ANOTHER ISSUE HERE!
    ------------------------------------------------
    pTest = new Test;
    ------------------------------------------------
    This statement involves 3 steps:
    (1) Allocate memory;
    (2) Construct the object;
    (3) Assign the address to pTest; 

    And (2)(3) could be in reverse order. 
    If (2) is last, it is possible when you leave it, the pTest has a value, but the content hasn't been constructed.
    Then a following thread refers to this un-initialized area by the pointer pTest, which itself is good.
    
    So the key point is to make "pTest = new Test;" executed in once.

    [Solution 3 - SECOND RECOMMENDED] std::call-once()
    It makes sure a function is only called once, by usin a flag; and when it is executed, it is not interrupted.

    [Solution 4] Double-Check Locking with C++17 Compiler or Later
    C++17 Compiler or Later makes sure that when you have a pointer, it is constructed.
    So the "BUT THERE IS ANOTHER ISSUE HERE!" doesn't exist anymore.

13. Dead Lock

    An example of dead lock:
    ------------------------------------------------------------------
    Thread A locks Mutex1;              Thread B locks Mutex2;
    Then it tries to lock Mutex2;       Then it tries to lock Mutex1;
    ------------------------------------------------------------------

    [A simple, illustrative solution]
    Thread A and B try to lock multiple mutexs in the same order; and the thread succeeds to lock the first one can try
    to lock the second.
    ------------------------------------------------------------------
    Thread A trys to lock Mutex1;              Thread B tries to locks Mutex1;
    Thread A locks Mutex1;                     Failed;
    Thread A trys to lock Mutex2;              Failed;
    Thread A locks Mutex2;                     Failed;
    Thread A releases all Mutexs;              Thread B locks Mutex1;
                                               ...
    ------------------------------------------------------------------
    In real case, it is hard to figure out and control the order of lock between different threads.

    [Dinning Philosophers Problem]
    5 philosophers are sitting around a round desk, with 5 plates of food, and 5 fork between the plates.
    (1) They need 2 forks to be able to eat;
    (2) Forks must be picked one by one;
    (3) All the philosophers pick up their left fork at the same time. They wait to pick up their right
        fork (which is also their neighbour's left fork);
    (4) A philosopher, who has picked up one fork, will wait for a certain time for the second fork. He will think in this
        timeout. If he can't get the second fork in this timeout, he will put down his first fork;
    (5) When finished eating, forks can be put down immediately;

    Philosophers : Threads;
    Forks        : Mutex;

