1. std::thread th(FunctionName) will create a new thread and run it immediately. The thread function can't be overloaded. 
   So don't use an existing function name.

2. std::ref() and its purpose in CodeList.txt.

3. std::thread is C++ interface for multithreading, but it doesn't implement all necessary functions for multithreading 
   because we want a implementation portable to all platforms, and some platforms are limited.
   
   One function that C++ std::thread doesn't provide is setting the priority of thread.

   Thread affinity is to assign a thread on a specific core or not. Usually scheduler will move a thread on different core
   if it think necessary. But this move would involve context switch.

   native_handle() member function is something that the thread implementation would use to associate with the std::thread.
   It returns different value, and has different meaning for different platforms. See code example and CodeList.txt for this.

4. std::thread is implemented using RAII. What does this mean?
   When passing thread as a function argument, it can only be done with std::move(). Don't do it with value passing.
   When returning a thread, compiler will always do std::move() to it.

5. A thread's exception should be handled in the thread itself. Other thread, incluing its parent, can't handle for it.
   If no suitable handler is found, the whole program will be terminated.
 
6. std::thread doesn't support kill to it. You may rely on OS to kill it.

-------------------------------------------------------------------------------------------------------------------------------
7. Data Race
   When several threads are accessing the same memory location and one of the thread is trying to modify it, this modification
   may be interrupted by other threads, due to lack of synchonization, before it is done. So the data is corrupted here.
   
   We may enforce a sequential access to this shared data between threads, and threads will still run concurrently at other 
   time.

   Critical section is the code section that requires execution thread by thread. Usually it is where shared data is. 

8. Thread synchronization, by Mutex, is the solution to data race.
   std::mutex is a class, with 3 member functions only: 
   (1) lock()     : Locks the mutex, blocks if the mutex is not available. Block until succeed.
       Potential danger that if it keeps failing to lock, the thread will keeps running forever.
   (2) try_lock() : Tries to lock the mutex, returns if the mutex is not available;  
   (3) unlock()   : Unlocks the mutex;

   You can set std::mutex as your class member to protect the access to your class data.
   For this case, we should use mutex to do synchronization for both reader and writer for a critical region.
   
   *************************************************************************************************************************
   std::mutex is not usaully directly manipulated using these 3 functions. 
   The reason is: If there is any exception throw() between lock() and unlock(), the mutex will never be released, so other
   threads will be blocked there, waiting for the mutex. So is the main(), which will also be blocked forever.
   *************************************************************************************************************************

   It is more commonly operated by std::unique_lock, std::lock_guard, or std::scoped_lock (since C++17) manage locking in a 
   more exception-safe manner. 
   This is RAII way. Basically, the constructor locks, and their destructor unlocks. And we create these classes on stack.
   
   (1) std::lock_guard - It only has constructor, with mutex as parameter, and destructor.
       std::lock_guard<std::mutex> lockGuard(myMutexObj);
   
   (2) std::unique_lock - Similar to std::lock_guard on the constructor locks, and the destructor unlocks. It also has a
       specific unlock() function to solve the problem of double unlock() about std::lock_guard, which is shown 
       in 10-1-RAII-LockGuard.cpp.

       std::unique_lock als has some more features.

    In general, if you want to lock the whole scope, use std::lock_guard, otherwise, like you want to lock inside the scope,
    or need othere features, use std::unique_lock.

    std::timed_mutex 
    (1) It supports delayed lock/unlock operations, such as try_lock_for() and try_lock_until(). Take try_lock_for() as example, 
        it will keep trying lock() in the specified duration, and return true/false when this duration is over;
    (2) We can also use std::unique_lock() to wrap a std::timed_mutex.
        std::unique_lock() also has member function try_lock_for() and try_lock_until(), and they are usable when std::unique_lock()
        is wrapping a std::timed_mutex, not just std::mutex.

    So 2 ways:
    std::timed_mutex.try_lock_for()/until(), or, std::unique_lock<std::timed_mutex>.try_lock_for()/until().  
















