1.  If you run command 'cmake', you get:
    -------------------------------------------------------
    momo@Ubuntu-Linux-22-04:~/Cpp/CMake$ cmake
    Usage

    cmake [options] <path-to-source>
    cmake [options] <path-to-existing-build>
    cmake [options] -S <path-to-source> -B <path-to-build>
    -------------------------------------------------------

2.  Most people will make a directory called 'build' in their source directory, and put everything from building here.
    Simplest example:
    ------------------------------------------------------------------------------------------------------------------
    // Below CMakeLists.txt is empty. Cmake needs it to be there.
    momo@Ubuntu-Linux-22-04:~/Cpp/CMake$ ls
    CMakeLists.txt  HelloWorld.cpp  Knowledge-1.txt  build
    momo@Ubuntu-Linux-22-04:~/Cpp/CMake$ cmake -S ./ -B ./build/HelloWorld/
    CMake Warning (dev) in CMakeLists.txt:
    No project() command is present.  The top-level CMakeLists.txt file must
    contain a literal, direct call to the project() command.  Add a line of
    code such as

    project(ProjectName)

    near the top of the file, but after cmake_minimum_required().

    CMake is pretending there is a "project(Project)" command on the first line.
    This warning is for project developers.  Use -Wno-dev to suppress it.

    -- The C compiler identification is GNU 11.4.0
    -- The CXX compiler identification is GNU 11.4.0
    -- Detecting C compiler ABI info
    -- Detecting C compiler ABI info - done
    -- Check for working C compiler: /usr/bin/cc - skipped
    -- Detecting C compile features
    -- Detecting C compile features - done
    -- Detecting CXX compiler ABI info
    -- Detecting CXX compiler ABI info - done
    -- Check for working CXX compiler: /usr/bin/c++ - skipped
    -- Detecting CXX compile features
    -- Detecting CXX compile features - done
    -- Configuring done
    -- Generating done
    -- Build files have been written to: /home/parallels/Cpp/CMake/build/HelloWorld
    momo@Ubuntu-Linux-22-04:~/Cpp/CMake$ ls -l build/HelloWorld/
    total 28
    // Below files are generated by CMake. Don't touch it.
    -rw-rw-r-- 1 parallels parallels 13797 Mar  4 22:19 CMakeCache.txt
    drwxrwxr-x 4 parallels parallels  4096 Mar  4 22:19 CMakeFiles
    -rw-rw-r-- 1 parallels parallels  4077 Mar  4 22:19 Makefile
    -rw-rw-r-- 1 parallels parallels  1637 Mar  4 22:19 cmake_install.cmake
    momo@Ubuntu-Linux-22-04:~/Cpp/CMake$ ls
    CMakeLists.txt  HelloWorld.cpp  Knowledge-1.txt  build
    // CMakeLists.txt is still empty after cmake compile here.
    ------------------------------------------------------------------------------------------------------------------

    In the above example, the generated Makefile in build diretory is a long and complete one. But CMakeLists.txt is still empty.
    ** If you check the generated Makefile, it only has some general rules, doesn't have our .cpp file information in it.
    
    We need to edit the CMakeLists.txt file to contain source file information. And it is the line:
    ----------------------------------------------
    add_executable(${PROJECT_NAME} HelloWorld.cpp)
    ----------------------------------------------
    that enables Makefile contain our cource .cpp information.

    Then go to build/[ProjectFolder] to run command 'make' since the Makefile is here. You will get your executable file 
    with name set in project(HelloWorldExample) in CMakeLists.txt.

3.  Install
    # install will enable "make install" at make stage after cmake command.
    # It will copy generated executable file into /usr/local/bin so that you can run the command anywhere.
    install(TARGETS ${PROJECT_NAME} DESTINATION bin)

4. So basically:
    -------------------------------------------------------------------------------------------------------
    So here you first run "cmake -S ./ -B ../build/1-HelloWorld" to generate makefile, and then run "make install"
    to compile out executable file and install to /usr/local/bin.
    -------------------------------------------------------------------------------------------------------

    If you want to generate a library, it is almost the same for the CMakeLists.txt file, only to use
    add_library().

5. Project 2-SimpleLibrary and 2-TestSimpleLibrary show how to install library and its header file
   so that calling applications can call the library without need to consider its path;

